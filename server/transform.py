import os
import sys
from collections import Counter
from music21 import *
from keras.models import load_model
import numpy as np

model = load_model('./model/mewzic_model.h5')

def read_midi(file):

    # print("Parsing: ", file)
    notes = []
    notes_to_parse = None
    # parsing a midi file, getting a midi file in buffer
    midi = converter.parse(file)
    # grouping based on different instruments, sort by instrument
    try:
        instru = instrument.partitionByInstrument(midi)
        notes_to_parse = instru.parts[0].recurse()
    except:
        notes_to_parse = midi.flat.notes
    for element in notes_to_parse:
        # note
        if isinstance(element, note.Note):
            notes.append(str(element.pitch))
        # chord
        elif isinstance(element, chord.Chord):
            notes.append('.'.join(str(n) for n in element.normalOrder))
    return notes

def transform():
    # Array Processing
    # specify the path
    path = "/Users/MR_ME/Desktop/mewzic/server/user_upload_data/"  

    # read all the filenames
    files = [i for i in os.listdir(path) if i.endswith(".mid")]

    # make sure we only parse .midi files
    # reading each midi file
    # tuples to array conversion because list cant be hashed
    notes_array = [read_midi(path+i) for i in files]

    notes_ = [element for note_ in notes_array for element in note_]
    # No. of unique notes
    unique_notes = list(set(notes_))
    # number of notes
    n_vocab = len(unique_notes)

    freq = dict(Counter(notes_))
    no = [count for _, count in freq.items()]
    frequent_notes = [note_ for note_, count in freq.items() if count >= 5]
    # print(len(frequent_notes))

    new_music = []
    # this adds the most freq notes to a new list new_mewzic
    for notes in notes_array:
        temp = []
        for note_ in notes:
            if note_ in frequent_notes:
                temp.append(note_)
        new_music.append(temp)
    new_music = np.array(new_music)

    no_of_timesteps = 128  # aka sequence length
    x = []

    for note_ in notes_array:
        for i in range(0, len(note_) - no_of_timesteps, 1):
            # preparing input and output sequences
            input_ = note_[i:i + no_of_timesteps]
            # output = note_[i + no_of_timesteps]
            x.append(input_)
    x = np.array(x)
    n_seq = len(x)

    # numpy.ravel() == numpy.reshape(-1) aka flatten to a 1d array
    unique_x = list(set(x.ravel()))
    # creating a dict with key as note and value as freq count
    x_note_to_int = dict((note_, number)
                         for number, note_ in enumerate(unique_x))

    x_seq = []
    for i in x:
        temp = []
        for j in i:
            # assigning unique integer to every note
            temp.append(x_note_to_int[j])
        x_seq.append(temp)
    x_seq = np.array(x_seq)

    start = np.random.randint(0, 63)
    x_int_to_note = dict((number, note_) for number, note_ in enumerate(unique_x))
    seq = x_seq[start]
    predictions = []
    for i in range(64):
        pred_ip = np.reshape(seq, (1, len(seq), 1))
        pred_ip = pred_ip/len(pred_ip)
        prediction = model.predict(pred_ip)
        index = np.argmax(prediction)
        result = x_int_to_note[index]
        predictions.append(result)  
        seq = np.append(seq, index)
        seq = seq[1:len(seq)]

    offset = 0


    output_notes = []
    # create note and chord objects based on the values generated by the model
    for pattern in predictions:
        # pattern is a chord
        if ('.' in pattern) or pattern.isdigit():
            notes_in_chord = pattern.split('.')
            notes = []
            for current_note in notes_in_chord:
                cn = int(current_note)
                new_note = note.Note(cn)
                new_note.storedInstrument = instrument.Piano()
                notes.append(new_note)
            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            output_notes.append(new_chord)
        # pattern is a note
        else:
            new_note = note.Note(pattern)
            new_note.offset = offset
            new_note.storedInstrument = instrument.Piano()
            output_notes.append(new_note)
        # increase offset each iteration so that notes do not stack
        offset += 0.54
    midi_stream = stream.Stream(output_notes)
    midi_stream.write('midi', fp='user_output_data/client_output.mid')


    return predictions




if __name__ == '__main__':
    # print(pre_process())
    print(transform())
